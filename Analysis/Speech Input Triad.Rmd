---
title: "Speech Input Triad"
author: ""
date: "August 28, 2019"
output: 
   html_document: 
     dev: png
     fig_height: 5
     fig_width: 5.5
     number_sections: yes
     toc: yes
     toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ARTool)
library(reshape2)
library(ez)
library(apa)
library(gridExtra)
library(phia)
library(viridis)
library(lsmeans)
library(gmodels)
library(DescTools)
library(MASS)
library(pander)
library(reticulate)
library(ggpubr)
library(xtable)
library(emmeans)
# Needed to correctly export fonts in pdf (may not be required)
library(extrafont)
# Need to call extrafont::font_import() once in console and restart RStudio
```

```{r functions, echo=FALSE, warning=FALSE}

normalCheck = function(model) {
    res = residuals(model)
    qqnorm((res - mean(res)) / sd(res))
    abline(0, 1)
    print (shapiro.test(res))
}

createPlot = function(data, mean_var, cl_var, cu_var, vj, lx, ly, y_axis, lim_min = 0, lim_max = 33, breaks = 5, x_var = "taskType", angle = 0) {
  localenv <- environment()
  if (is.element(mean_var, c("mIT", "mTT", "mET", "mPT", "mCT"))) {
    data[mean_var] = data[mean_var] / 1000
    data[cl_var] = data[cl_var] / 1000
    data[cu_var] = data[cu_var] / 1000
  } 
  
  if (mean_var=="m_cer" | mean_var=="m_uer") {
    data[mean_var] = data[mean_var] * 100
    data[cl_var] = data[cl_var] * 100
    data[cu_var] = data[cu_var] * 100
  }
  
  ggplot(data, aes(x=data[[x_var]], y=data[[mean_var]], fill=inputType), environment = localenv ) +
  geom_bar(aes(group=inputType), position = position_dodge(.7), colour="black", stat="identity", width=.7) +
  geom_errorbar(aes(ymin = data[[cl_var]], ymax = data[[cu_var]]), width = 0.2, size = .7, position = position_dodge(.7)) +
  #geom_text(aes(label=round(data[[mean_var]],digits=2)), size = 4, position = position_dodge(0.7), vjust = vj, alignment="center") +
  scale_x_discrete(name="Task") +
  scale_y_continuous(name=y_axis, limits = c(lim_min, lim_max), minor_breaks = breaks, expand = c(0, 0)) +
  #scale_fill_viridis(option="inferno", begin=0.5, end = .8, discrete = TRUE) +
  #scale_fill_viridis(option="magma", begin=0.5, end = .8, discrete = TRUE) +
  scale_fill_manual(values=c("#DF5E28", "#F6C584")) +
  labs(fill = "Input Type") +
  theme(legend.position = c(lx, ly),
        legend.box.background = element_rect(size=1, color="black"),
        legend.background = element_rect(size = 0.3, linetype = "solid", colour = "black"),
        panel.background = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(),
        axis.title = element_text(family="Helvetica", face="bold", colour="black", size="10"),
        axis.text = element_text(family="Helvetica", colour="black", size="10"),
        axis.text.x=element_text(angle=angle, hjust=1),
        panel.grid.major.y = element_line( size = .1, color = "grey"))
}
```

```{python usefulfunctions, echo=FALSE}
import re
def parseAnova(s):
  aovres = re.findall(r'[-+]?\d*\.\d+|\d+',s)
  return "\\anova{%s}{%s}{%s}{%s}{%s}"%(aovres[0], aovres[1], aovres[2], aovres[3], aovres[4])
  
def writeToFile(s, file):
  f = open("autogen/" + file,"w+")
  f.write("% do not edit this file as it was automatically generated\n\n")
  f.write(s)
  f.close()
```

# Data Parsing

## Loading Data

Filtering out invalid participants (9, 10, and 14).

```{r load}
data_c = read.csv("parse_more.csv",sep=",") %>% filter(!participantNo %in% c(9, 10, 14))
data_c = data_c[,!names(data_c) %in% c("incorrect_fixed", "fixes", "correct", "inf","msg", "correctMsg", "gMsg")]
data_c.kbd = filter(data_c, inputType=="Keyboard")
data_c.sr = filter(data_c, inputType=="Speech")

data_t = read.csv("parse_more_trans.csv",sep=",")
data_t = data_t[,!names(data_t) %in% c("incorrect_fixed", "fixes", "correct", "inf", "msg", "orgMsg")]
data_t$setNum = substr(data_t$setNum, 1, 1)
data_t.kbd = filter(data_t, inputType=="Keyboard")
data_t.sr = filter(data_t, inputType=="Speech")

```

## Outlier Culling

I removed values outside of 3 standard deviations for the means of each task x method combination, for totalTime.

22 outliers identified for composition (2.04% of trials)

```{r outliers_comp, warning=FALSE, message=FALSE, echo=FALSE}
dcs = summarize(group_by(data_c, inputType), mIT = mean(inputTime), sdIT = sd(inputTime), mPT = mean(prepTime), sdPT = sd(prepTime), mET = mean(entryTime), sdET=sd(entryTime), mTT = mean(totalTime), sdTT = sd(totalTime), meanWpm = mean(wpm), sdWpm = sd(wpm), mean_uer = mean(uncorrected_error_rate), sd_uer = sd(uncorrected_error_rate), mean_cer= mean(corrected_error_rate), sd_cer = sd(corrected_error_rate), mean_bd = mean(bandwidth))

cko.tt <- filter(data_c.kbd, totalTime < (dcs$mTT[1] - 3 * dcs$sdTT[1]) | totalTime > (dcs$mTT[1] + 3 * dcs$sdTT[1]))
cso.tt <- filter(data_c.sr, totalTime < (dcs$mTT[2] - 3 * dcs$sdTT[2]) | totalTime > (dcs$mTT[2] + 3 * dcs$sdTT[2]))
co.tt <- bind_rows(cko.tt, cso.tt)

data_c.clean = anti_join(data_c, co.tt)
#remove(co.all, co.it, co.pt, co.et, co.tt, co.wpm, co.uer, co.cer)
```

26 outliers identified for transcription (2.32% of trials)

```{r outlier_trans, warning=FALSE, message=FALSE, echo=FALSE}
dts = summarize(group_by(data_t, inputType), mIT = mean(inputTime), sdIT = sd(inputTime), mPT = mean(prepTime), sdPT = sd(prepTime), mET = mean(entryTime), sdET=sd(entryTime), mTT = mean(totalTime), sdTT = sd(totalTime), meanWpm = mean(wpm), sdWpm = sd(wpm), mean_uer = mean(uncorrected_error_rate), sd_uer = sd(uncorrected_error_rate), mean_cer= mean(corrected_error_rate), sd_cer = sd(corrected_error_rate), mean_bd = mean(bandwidth))

tko.tt <- filter(data_t.kbd, totalTime < (dts$mTT[1] - 3 * dts$sdTT[1]) | totalTime > (dts$mTT[1] + 3 * dts$sdTT[1]))
tso.tt <- filter(data_t.sr, totalTime < (dts$mTT[2] - 3 * dts$sdTT[2]) | totalTime > (dts$mTT[2] + 3 * dts$sdTT[2]))
to.tt <- bind_rows(tko.tt, tso.tt)
# 
# to.all <- bind_rows(to.it, to.pt, to.et, to.tt, to.wpm, to.uer, to.cer)
# to <- unique(to.all)

data_t.clean = anti_join(data_t, to.tt)
#remove(to.all, to.it, to.pt, to.et, to.tt, to.wpm, to.uer, to.cer)

```

## Data Aggregation

Aggregating the cleaned data

```{r warning=FALSE}
data = bind_rows(data_t.clean, data_c.clean)

data.group = summarize(group_by(data, participantNo, inputType, taskType, setNum), meanInputTime = mean(inputTime), meanPrepTime = mean(prepTime), meanEntryTime = mean(entryTime), meanTotalTime = mean(totalTime), meanLen = mean(msgLen), meanWpm = mean(wpm), mean_uer = mean(uncorrected_error_rate), mean_cer= mean(corrected_error_rate), mean_bd = mean(bandwidth), meanCorrTime = mean(corrTime))

data.stats = dplyr::bind_rows(data_c.clean, data_t.clean) %>% 
  group_by(inputType, taskType) %>% 
  summarize(mIT = mean(inputTime), cuIT = ci(inputTime)[3], clIT = ci(inputTime)[2], sdIT = sd(inputTime),
            mPT = mean(prepTime), cuPT = ci(prepTime)[3], clPT = ci(prepTime)[2], sdPT = sd(prepTime),
            mET = mean(entryTime), cuET=ci(entryTime)[3], clET = ci(entryTime)[2], sdET = sd(entryTime),
            mTT = mean(totalTime), cuTT = ci(totalTime)[3], clTT = ci(totalTime)[2], sdTT = sd(totalTime),
            mCT = mean(corrTime), cuCT = ci(corrTime)[3], clCT = ci(corrTime)[2], sdCT = sd(corrTime),
            mWpm = mean(wpm), cuWpm = ci(wpm)[3], clWpm = ci(wpm)[2], sdWpm = sd(wpm),
            m_uer = mean(uncorrected_error_rate), cu_uer = ci(uncorrected_error_rate)[3], cl_uer = ci(uncorrected_error_rate)[2], sd_uer = sd(uncorrected_error_rate),
            m_cer= mean(corrected_error_rate), cu_cer = ci(corrected_error_rate)[3], cl_cer = ci(corrected_error_rate)[2], sd_cer = sd(corrected_error_rate)) 

data.long = melt(data.group, id = c("participantNo", "inputType", "taskType", "setNum", "meanInputTime", "meanPrepTime", "meanWpm", "meanTotalTime", "meanEntryTime", "meanLen", "mean_uer", "mean_cer", "mean_bd", "meanCorrTime"))

data.long$participantNo <- factor(data.long$participantNo)
data.long$inputType <- factor(data.long$inputType)

data.long.c = filter(data.long, taskType == "Composition")
data.long.c = data.long.c[,!names(data.long.c) %in% c("taskType")]

data.long.t = filter(data.long, taskType == "Transcription")
data.long.t = data.long.t[,!names(data.long.t) %in% c("taskType")]

data.long$setNum <- factor(data.long$setNum)
data.long$taskType <- factor(data.long$taskType)

data.long.c$setNum <- factor(data.long.c$setNum)
data.long.t$setNum <- factor(data.long.t$setNum)
```

Output data stats to a Latex table

Psych, this didn't actually work that well....
```{r}
#data.stats.i = unite(data.stats, "ti", taskType, inputType) 
#data.stats.i = data.stats.i[order(data.stats.i$ti),]

#data.tbl <- dplyr::select(data.stats.i, ti, mTT, sdTT, mIT, sdIT, mPT, sdPT, mET, sdET, mWpm, sdWpm, m_uer, sd_uer, m_cer, sd_cer) %>% t %>% as.data.frame()

#print(xtable(data.tbl, type = "latex"), file = "autogen/table.tex")
```

# Composition Phrase Analysis

Aggregating and filtering data
```{r warning=FALSE, message=FALSE}
msg.group.stats <- data_c.clean %>% group_by(inputType, triad) %>% 
  summarize(mLen = mean(msgLen), cuLen = ci(msgLen)[3], clLen = ci(msgLen)[2], sdLen = sd(msgLen),
            mIT = mean(inputTime), cuIT = ci(inputTime)[3], clIT = ci(inputTime)[2], sdIT = sd(inputTime),
            mPT = mean(prepTime), cuPT = ci(prepTime)[3], clPT = ci(prepTime)[2], sdPT = sd(prepTime),
            mET = mean(entryTime), cuET=ci(entryTime)[3], clET = ci(entryTime)[2], sdET = sd(entryTime),
            mTT = mean(totalTime), cuTT = ci(totalTime)[3], clTT = ci(totalTime)[2], sdTT = sd(totalTime))

msg.group <- data_c.clean %>% group_by(inputType, triad) %>% 
  summarize(mLen = mean(msgLen), mIT = mean(inputTime), mPT = mean(prepTime), mET = mean(entryTime), mTT = mean(totalTime), m_uer = mean(uncorrected_error_rate), m_cer = mean(corrected_error_rate))

msg.group.ni <- data_c.clean %>% group_by(triad) %>% 
  summarize(mLen = mean(msgLen), mIT = mean(inputTime), mPT = mean(prepTime), mET = mean(entryTime), mTT = mean(totalTime))

msg.long = melt(msg.group, id = c("triad", "inputType", "mLen", "mIT", "mPT", "mET", "mTT", "m_uer", "m_cer"))

msg.long$triad <- factor(msg.long$triad)
msg.long$inputType <- factor(msg.long$inputType)
```

## Message Length

```{r}
mean(data_c.clean$msgLen)
sd(data_c.clean$msgLen)

max(data_c.clean$msgLen)
min(data_c.clean$msgLen)
#data_c.clean[which.min(data_c.clean$msgLen),]

max(msg.group.ni$mLen)
msg.group.ni[which.max(msg.group.ni$mLen),]$triad

min(msg.group.ni$mLen)
msg.group.ni[which.min(msg.group.ni$mLen),]$triad
```

```{r warning=FALSE, message=FALSE}
createPlot(msg.group.stats, "mLen", "clLen", "cuLen", 2.5, 0.25, 0.82, "Average Length", 0, 210, 50, "triad", 45)

# ggplot(msg.group.stats, aes(x=triad, y=mLen, fill=inputType)) + 
#   geom_bar(aes(group=inputType), position = position_dodge(.7), colour="black", stat="identity", width=.7) + 
#   geom_errorbar(aes(ymin = clLen, ymax = cuLen), width = 0.2, size = .5, position = position_dodge(.7)) +
#   #geom_text(aes(label=round(mLen,digits=2)), size = 3, position = position_dodge(0.7), vjust = 2.5, alignment="center") +
#   scale_x_discrete(name="Image Triad") +
#   scale_y_continuous(name="Average Length", limits = c(0, 210), minor_breaks = 50, expand = c(0, 0)) +
#   scale_fill_manual(values=c("#DF5E28", "#F6C584")) +
#   labs(fill = "Input Type") +
#   theme(legend.position = c(.25,.82),
#         legend.box.background = element_rect(size=1, color="black"),
#         legend.background = element_rect(size = 0.3, linetype = "solid", colour = "black"),
#         panel.background = element_blank(),
#         panel.border = element_blank(),
#         axis.line = element_line(),
#         axis.title = element_text(family="Helvetica", face="bold", colour="black", size="10"),
#         axis.text = element_text(family="Helvetica", colour="black", size="10"),
#         axis.text.x=element_text(angle=45, hjust=1),
#         panel.grid.major.y = element_line( size = .1, color = "grey"),
#         legend.title = element_text(family="Helvetica", face="bold", colour="black", size="8"),
#         legend.text = element_text(family="Helvetica", face="bold", colour="black", size="8")) 

ggsave("figures/len.pdf",
       height = 7 , width = 10,
       plot = last_plot(), # or give ggplot object name as in myPlot,
       dpi = 300)

```

## Effect of Triad on Message Length

```{r}
# m <- aov(mLen ~ triad, data=msg.long)
# pander(normalCheck(m))
# 
# boxcox(mLen ~ triad, data=msg.long, plotit=T)
# 
# datatr = msg.long %>% mutate(mLen = mLen^(1.9))
# 
# m <- aov(mLen ~ triad, data=datatr)
# pander(normalCheck(m))
```

This didn't work - I just went with the ART

```{r}
a = art(mLen ~ triad, data=msg.long)
anova(a)
```

### Post-Hoc Comparisons
```{r}
e = emmeans(artlm(a, "triad"), pairwise ~ triad)
e$contrasts
```

Looks like there is a significant effect of trial on message length 

## Input Time?

```{r warning=FALSE, message=FALSE}
ggplot(msg.group.stats, aes(x=triad, y=mIT/1000, fill=inputType)) + 
  geom_bar(aes(group=inputType), position = position_dodge(.7), colour="black", stat="identity", width=.7) + 
  geom_errorbar(aes(ymin = clIT/1000, ymax = cuIT/1000), width = 0.2, size = .7, position = position_dodge(.7)) +
  #geom_text(aes(label=round(mIT/1000,digits=2)), size = 4, position = position_dodge(0.7), vjust = 3.5, alignment="center") +
  scale_x_discrete(name="Task") +
  scale_y_continuous(name="Average Input Time (s)", limits = c(0, 47), minor_breaks = 5, expand = c(0, 0)) +
  #scale_fill_viridis(option="inferno", begin=0.5, end = .8, discrete = TRUE) +
  scale_fill_manual(values=c("#DF5E28", "#F6C584")) +
  labs(fill = "Input Type") +  
  theme(legend.position = c(.25,.82),
        legend.box.background = element_rect(size=1, color="black"),
        legend.background = element_rect(size = 0.3, linetype = "solid", colour = "black"),
        panel.background = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(),
        axis.title = element_text(family="Helvetica", face="bold", colour="black", size="10"),
        axis.text = element_text(family="Helvetica", colour="black", size="10"),
        axis.text.x=element_text(angle=45, hjust=1),
        panel.grid.major.y = element_line( size = .1, color = "grey"),
        legend.title = element_text(family="Helvetica", face="bold", colour="black", size="8"),
        legend.text = element_text(family="Helvetica", face="bold", colour="black", size="8")) 
```

```{r}

a = art(mIT ~ triad, data=msg.long)
anova(a)
```
No effect of triad on input time

``` {r warning=FALSE, message=FALSE}
ggplot(msg.group.stats, aes(x=triad, y=mPT/1000, fill=inputType)) + 
  geom_bar(aes(group=inputType), position = position_dodge(.7), colour="black", stat="identity", width=.7) + 
  geom_errorbar(aes(ymin = clPT/1000, ymax = cuPT/1000), width = 0.2, size = .5, position = position_dodge(.7)) +
  #geom_text(aes(label=round(mPT/1000,digits=2)), size = 4, position = position_dodge(0.7), vjust = -2, alignment="center") +
  scale_x_discrete(name="Task") +
  scale_y_continuous(name="Average Prep Time (s)", limits = c(0, 37), minor_breaks = 5, expand = c(0, 0)) +
  scale_fill_manual(values=c("#DF5E28", "#F6C584")) +
  labs(fill = "Input Type") +
  theme(legend.position = c(.25,.82),
        legend.box.background = element_rect(size=1, color="black"),
        legend.background = element_rect(size = 0.3, linetype = "solid", colour = "black"),
        panel.background = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(),
        axis.title = element_text(family="Helvetica", face="bold", colour="black", size="10"),
        axis.text = element_text(family="Helvetica", colour="black", size="10"),
        axis.text.x=element_text(angle=45, hjust=1),
        panel.grid.major.y = element_line( size = .1, color = "grey"),
        legend.title = element_text(family="Helvetica", face="bold", colour="black", size="8"),
        legend.text = element_text(family="Helvetica", face="bold", colour="black", size="8")) 
```

## Other Measures

```{r}

a = art(mPT ~ triad, data=msg.long)
anova(a)
```

No effect of triad on prep time either

```{r}

a = art(mET ~ triad, data=msg.long)
anova(a)

a = art(mTT ~ triad, data=msg.long)
anova(a)

a = art(m_uer ~ triad, data=msg.long)
anova(a)

a = art(m_cer ~ triad, data=msg.long)
anova(a)
```

No significant effect of triad on any of these measures